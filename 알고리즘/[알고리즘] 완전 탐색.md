# [알고리즘] 완전 탐색
---------------------
### 완전 탐색 알고리즘이란?   
가능한 모든 경우를 전부 탐색하여 답을 찾는 알고리즘 설계 방법   
이 방법은 단순하면서도 직관적이기 때문에 이해하기 쉽고, 상대적으로 구현이 간단하다.   
문제의 가능한 모든 조합이나 상태를 일일이 확인하기 때문에 항상 정확한 해를 찾을 수 있다.     
하지만 모든 경우의 수를 확인하기 때문에, 큰 메모리를 사용하며 시간복잡도가 크다.
경우의 수에 따라 실행 시간이 비례하기 때문에 입력 값의 범위가 적은 경우에 유용하다.   

---------------------
## 1. 단순 완전 탐색
- 특별한 기법 없이 for문(반복문)과 if문(조건문)으로 모든 경우의 수를 체크하여 답을 구하는 방법   
- 해당 방법으로 해결할 수 있는 문제가 많지 않다.   
- 시간복잡도가 매우 높을 수 있다.   

## 2. Bitmask(비트마스크)   
- 정수를 이진수로 표현하여 각 비트가 특정 상태를 나타내도록 하는 기법    
- 나올 수 있는 모든 경우의 수가 각각의 원소에 포함되거나, 포함되지 않는 두가지 선택으로 구성되는 경우 유용하게 사용   
ex) 원소가 n개인 집합의 부분 집합 구하기

## 3. 재귀(Recursion)   
> 재귀(Recursion)은 자기 자신을 호출한다는 뜻이다.   
- 재귀함수는 자기 자신(함수)을 호출하여 작업을 수행한다.   
- 무한 루프 발생을 방지하기 위한 탈출 조건이 필요하다.   
ex) 팩토리얼
```java
public int factorial(int n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); 
}
```

## 4. 순열(Permutation)   
순열은 주어진 요소들을 순서를 고려하여 나열한 모든 경우의 수   
- 서로 다른 n개를 일렬로 나열하는 방법
- 주어진 순서나 경우의 수를 모두 탐색해야하는 문제에서 사용된다.
- n!개의 경우의 수   
- 시간복잡도: O(N!)

## 5. 조합(Combination)   

## 6. DFS(Depth-First Search)   

## 7. BFS(Breadth-First Search)   
